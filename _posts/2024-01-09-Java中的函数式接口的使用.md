---
title: Java中函数式接口的使用
categories:
- 工作记录
tags:
- Java
- 函数式接口
- 泛型
---
> 今天在编写一个调用第三方api的逻辑时封装了一个公共方法，这个方法可以传入自定义请求头和body然后返回一个HttpResponse(这个HttpResponse是hutool中的工具类)，但是调用这个方法后还需要通过HttpResponse.body获取响应数据再进行解析。于是我就想能不能调用这个方法后直接就返回我想要的结果，回想起以前在spring源码中getSingleton(String beanName, ObjectFactory<?> singletonFactory)中使用了函数式接口来传递一个自定义函数，所以我也使用函数式接口对这个请求方法进行改造。

<!-- more -->

## 1.先看最终实现

方法如下：这里使用了java自带的Function接口。

```java
   /**
     * 发送post请求(header中带apiKey)
     * @param url 请求地址
     * @param apiKey header中的apiKey
     * @param data 请求参数
     * @param parser 解析函数
     * @param <R> 解析函数的返回值类型
     * @return 将解析函数的返回值直接返回
     */
    private <R> R doPost(String url, String apiKey, Map data, Function<HttpResponse, R> parser) {
        HttpRequest post = HttpUtil.createPost(url);
        HashMap<String, String> headersMap = new HashMap<>();
        headersMap.put("Content-Type", "application/json");
        headersMap.put("ApiKey", apiKey);
        post.addHeaders(headersMap);
        post.body(JSON.toJSONString(data));
        try (HttpResponse response = post.execute()) {
            return parser.apply(response);
        } catch (Exception e) {
            log.error("数据解析异常",e);
        }
        return null;
    }
```

调用：

``` java
    public List<MyDTO> getData(String apiKey, String customKey, String projectKey) {
        String url = "http://localhost:18080/record";
        HashMap<String, String> bodyMap = new HashMap<>();
        bodyMap.put("CustomerKey", customKey);
        bodyMap.put("ProjectKey", projectKey);
        return doPost(url, apiKey, bodyMap, response -> {
            List<MyDTO> myDTOS;
            String body = response.body();
            Map responseMap = JSON.parseObject(body, Map.class);
            Map data = MapUtils.getMap(responseMap, "data");
            String photos = MapUtils.getString(data, "photos");
            myDTOS = JSONArray.parseArray(photos, MyDTO.class);
            return myDTOS;
        });
    }


    private List<Integer> getMid(String apiKey, String customKey, String projectKey) {
        String url = "http://localhost:18080/info";
        HashMap<String, String> bodyMap = new HashMap<>();
        bodyMap.put("CustomerKey", customKey);
        bodyMap.put("ProjectKey", projectKey);
        return doPost(url, apiKey, bodyMap, response -> {
            String body = response.body();
            Map responseMap = JSON.parseObject(body, Map.class);
            Map data = MapUtils.getMap(responseMap, "data");
            String meterStr = MapUtils.getString(data, "meters");
            List<Map> meters = JSONArray.parseArray(meterStr, Map.class);
            return meters.stream()
                    .map(map -> map.get("mid"))
                    .map(Object::toString)
                    .map(Integer::valueOf)
                    .collect(Collectors.toList());
        });
    }
```

两个方法中在调用doPost方法时传递了一个lambda函数，这个函数实现了各自的response解析方法并返回了各自需要的返回值。

## 2. 关于Function接口

  这里的doPost方法中使用了Java8自带的Function函数式接口，这个接口的定义

```java
@FunctionalInterface
public interface Function<T, R> {

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);

    /**
     * Returns a composed function that first applies the {@code before}
     * function to its input, and then applies this function to the result.
     * If evaluation of either function throws an exception, it is relayed to
     * the caller of the composed function.
     *
     * @param <V> the type of input to the {@code before} function, and to the
     *           composed function
     * @param before the function to apply before this function is applied
     * @return a composed function that first applies the {@code before}
     * function and then applies this function
     * @throws NullPointerException if before is null
     *
     * @see #andThen(Function)
     */
    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }

    /**
     * Returns a composed function that first applies this function to
     * its input, and then applies the {@code after} function to the result.
     * If evaluation of either function throws an exception, it is relayed to
     * the caller of the composed function.
     *
     * @param <V> the type of output of the {@code after} function, and of the
     *           composed function
     * @param after the function to apply after this function is applied
     * @return a composed function that first applies this function and then
     * applies the {@code after} function
     * @throws NullPointerException if after is null
     *
     * @see #compose(Function)
     */
    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }

    /**
     * Returns a function that always returns its input argument.
     *
     * @param <T> the type of the input and output objects to the function
     * @return a function that always returns its input argument
     */
    static <T> Function<T, T> identity() {
        return t -> t;
    }
}
```

这个接口中有个apply抽象方法，这个方法的作用是接收一个参数，返回一个结果；后面还有两个默认方法暂时没有使用。并且在这个接口中使用了泛型，可以根据自己的需要来确定入参和返回值的类型非常符合这个应用场景。
  