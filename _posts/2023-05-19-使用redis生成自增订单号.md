---
title: 使用redis生成自增的工单号
categories:
- java
- redis
tags:
- 工作记录
---

 工作中遇到一个根据规则：X+yyyyMMdd+001-9999自动生成订单号的需求，在这记录下实现过程。

<!-- more -->

## 1.通过redis的incr命令生成001-99999自增后缀

> Redis Incr 命令将 key 中储存的数字值增一。
>
> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
>
> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
>
> 本操作的值限制在 64 位(bit)有符号数字表示之内。

在springboot环境中使用redisTemplate进行上述操作，并封装成工具类

```java
/**
 * @author: L
 * @date: 2023/05/17
 * @description: 利用redis原子性生成订单号工具类
 */
@Component
public class GenerateOrderNoUtil {

    @Resource(name = "redisTemplateForOrderNo")
    private RedisTemplate<String, Long> redisTemplate;

    /**
     * 获取工单号后缀
     *
     * @param workOrderPrefix 工单前缀
     * @return 工单号后缀
     */
    public String getWorkOrderSuffix(String workOrderPrefix) {
        Long suffixNum = redisTemplate.opsForValue().increment(workOrderPrefix, 1L);
        if (suffixNum.intValue() == 1) {
            // 设置过期时间
            redisTemplate.expire(workOrderPrefix, 24, TimeUnit.HOURS);
        }
        if (suffixNum.intValue() < 100) {
            // 补够3位
            return String.format("%03d", Convert.toInt(suffixNum));
        } else {
            return Convert.toStr(suffixNum);
        }
    }
}
```

因为使用了RedisTemplate<String, Long> key,value为String,Long的泛型类型，但是项目中之前的RedisConfig文件中只配置了一个 RedisTemplate<Object, Object> redisTemplate的bean，导致工具类的注入失败。修改配置类：

```java
@Bean
    @SuppressWarnings(value = { "unchecked", "rawtypes" })
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)
    {
        RedisTemplate<Object, Object> template = new RedisTemplate<>();
       //之前默认的配置 
        return template;
    }

    @Bean
    public RedisTemplate<String, Long> redisTemplateForOrderNo(RedisConnectionFactory connectionFactory)
    {
        RedisTemplate<String, Long> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());

        // 使用GenericJackson2JsonRedisSerializer来序列化和反序列化redis的value值
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        template.afterPropertiesSet();
        return template;
    }
```

添加了一个RedisTemplate<String, Long> redisTemplateForOrderNo的bean供工具类使用。

## 2.使用

> 只需要在需要生成的地方注入工具类即可

```java
RestController
@RequestMapping("/factory/common")
public class FactoryCommonController {

    @Autowired
    private GenerateOrderNoUtil generateOrderNoUtil;


    /**
     * 生成订单号码
     * @param code
     * @return
     */
    @GetMapping("/generateOrderNo/{code}")
    public AjaxResult generateOrderNo(@PathVariable("code") String code){
        String prefix = OrderNoPrefixEnum.getPrefixByCode(code);
        if (StrUtil.isEmpty(prefix)){
            return AjaxResult.error("未获取到订单类型的前缀！");
        }
        StringBuilder sbd = new StringBuilder(prefix);
        sbd.append(DateUtil.format(DateTime.now(),"yyyyMMdd"));
        sbd.append(generateOrderNoUtil.getWorkOrderSuffix(sbd.toString()));
        HashMap<String, String> map = new HashMap<>(1);
        map.put("orderNo",sbd.toString());
        return AjaxResult.success(map);
    }

}
```

我直接定义了一个公用的生成订单号接口供前端调用，只需要配置好订单号前缀枚举即可,枚举类如下：

```java
/**
 * @author: L
 * @date: 2023/05/17
 * @description: 用于管理生成订单编号时所使用的前缀和用于判断的订单类型编码
 */
public enum OrderNoPrefixEnum {

    //备品备件入库
    FACTORY_RESERVE_STOCK_IN("stock-in", "R");

    /**
     * 用于判断的类型编码
     */
    private String code;
    /**
     * 拼接单号时所用的前缀
     */
    private String prefix;

    OrderNoPrefixEnum(String code, String prefix) {
        this.code = code;
        this.prefix = prefix;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getPrefix() {
        return prefix;
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public static String getPrefixByCode(String code) {
        for (OrderNoPrefixEnum value : OrderNoPrefixEnum.values()) {
            if (value.code.equals(code)){
                return value.prefix;
            }
        }
        return "";
    }
}

```

前端调用时只需要传入枚举类中的code。后面如果要添加其他类型的前缀只需要在枚举类中新建即可。